/*
 * Exopticon - A free video surveillance system.
 * Copyright (C) 2020 David Matthew Mattli <dmm@mattli.us>
 *
 * This file is part of Exopticon.
 *
 * Exopticon is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Exopticon is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Exopticon.  If not, see <http://www.gnu.org/licenses/>.
 */

//! Exopticon is a free video surveillance system

// to avoid the warning from diesel macros
#![allow(proc_macro_derive_resolution_fallback)]
#![deny(
    nonstandard_style,
    warnings,
    rust_2018_idioms,
    unused,
    future_incompatible,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo
)]
#![allow(clippy::integer_arithmetic)]
#![allow(clippy::integer_division)]
#![allow(clippy::missing_inline_in_public_items)]
#![allow(clippy::multiple_crate_versions)]
#![allow(clippy::implicit_return)]
#![allow(clippy::print_stdout)]
#![allow(clippy::expect_used)]
#![allow(clippy::future_not_send)]
#![allow(clippy::missing_errors_doc)] // TODO: Fix this one
#![allow(clippy::wildcard_imports)] // TODO: Fix DB handlers

#[macro_use]
extern crate base64_serde;
#[macro_use]
extern crate diesel;
#[macro_use]
extern crate diesel_migrations;
#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate failure;
#[macro_use]
extern crate log;
#[macro_use]
extern crate rust_embed;

/// Alert rule actor
mod alert_actor;

/// Alert rule db handlers
mod alert_rule_handler;

/// Alert rule routes
mod alert_rule_routes;

/// Actix route specification
mod app;

/// Implements authentication logic
mod auth_handler;

/// Implements auth routes
mod auth_routes;

/// Implements analysis actor
mod analysis_actor;

/// Implements db handlers for analysis
mod analysis_handler;

/// Implements analysis routes
mod analysis_routes;

/// Implements analysis supervisor
mod analysis_supervisor;

/// implements camera group api logic
mod camera_group_handler;

/// Implements camera group routes
mod camera_group_routes;

/// Implements camera api logic
mod camera_handler;

/// Implements camera api routes
mod camera_routes;

/// Actor that captures video from a camera
mod capture_actor;

/// Actor that supervises capture actors
mod capture_supervisor;

mod db_registry;

/// Error type
mod errors;

/// `FairQueue` implementation
mod fair_queue;

/// Actor that deletes excess files for a camera group
mod file_deletion_actor;

/// Actor that supervises files deletion workers
mod file_deletion_supervisor;

/// Implements handler for file io
mod file_handler;

/// Actor message structs
mod models;

/// Notifier db handlers
mod notifier_handler;

/// Notifier supervisor
mod notifier_supervisor;

/// Implemenents `DbExecutor` handler for creating and querying observations.
mod observation_handler;

///
mod observation_routes;

/// Implements playback actor
mod playback_actor;

/// Implements playback supervisor
mod playback_supervisor;

/// Implements prometheus registry
mod prom_registry;

/// Implements `DbExecutor` handler for creating users
mod register_handler;

/// Root supervisor, lauches `CaptureSupervisor` and `DeletionSupervisor`
mod root_supervisor;

/// Struct map writer so rmps-serde will output maps
mod struct_map_writer;

/// Database schema, generated by diesel
mod schema;

/// Routes for handling static files
mod static_routes;

/// telegram actor module
mod telegram_actor;

/// Routes for handling users
mod user_routes;

/// Utility functions
mod utils;

/// Implements handlers for `DbExecutor` concerning `VideoFile`s
mod video_file_handler;

/// Implements handlers for `DbExecutor` concerning `VideoUnit`s
mod video_unit_handler;

/// Implements routes for video units
mod video_unit_routes;

/// Implements camera frame pub/sub
mod ws_camera_server;

/// Implements a websocket session
mod ws_session;

use crate::models::DbExecutor;
use actix::prelude::*;
use actix_http::cookie::SameSite;
use actix_identity::{CookieIdentityPolicy, IdentityService};
use actix_web::{middleware::Logger, App, HttpServer};
use actix_web_prom::PrometheusMetrics;
use base64::{decode, encode};
use chrono::Duration;
use dialoguer::{Input, PasswordInput};
use diesel::{r2d2::ConnectionManager, PgConnection};
use dotenv::dotenv;
use rand::Rng;

use std::{env, thread};

use crate::app::RouteState;
use crate::models::{CreateCameraGroup, CreateUser};
use crate::root_supervisor::{ExopticonMode, RootSupervisor};

embed_migrations!("migrations/");

/// Interactively prompts the operator and adds a new user with the
/// details provided. This is for bootstrapping users on a new
/// install. It should be run before the main system is started.
///
/// # Arguments
///
/// * `sys` - The actix system runner
/// * `address` - The address of the `DbExecutor`
///

fn add_user(
    sys: &mut actix::SystemRunner,
    address: &Addr<DbExecutor>,
) -> Result<bool, std::io::Error> {
    let username = Input::new()
        .with_prompt("Enter username for initial user")
        .interact()?;

    let password = PasswordInput::new()
        .with_prompt("Enter password for initial user")
        .with_confirmation("Confirm password", "Passwords mismatching")
        .interact()?;

    let fut2 = address.send(CreateUser {
        username,
        password,
        timezone: String::from("UTC"),
    });

    match sys.block_on(fut2) {
        Ok(_) => (),
        Err(err) => {
            error!("Error creating user! {}", err);
        }
    }
    println!("Created User!");
    Ok(true)
}

/// Adds a camera group. This is really only for setting up initial
/// camera groups for boostrapping.. It should be run before the full
/// system is started.
///
/// # Arguments
///
/// * `sys` - The actix system runner
/// * `address` - The address of the `DbExecutor`
///

fn add_camera_group(
    sys: &mut actix::SystemRunner,
    address: &Addr<DbExecutor>,
) -> Result<bool, std::io::Error> {
    let storage_path = Input::new()
        .with_prompt("Enter storage path for recorded video")
        .interact()?;

    let max_storage_size: i64 = Input::new()
        .with_prompt("Enter max space used at this path, in megabytes")
        .interact()?;

    let fut = address.send(CreateCameraGroup {
        name: String::from("default"),
        storage_path,
        max_storage_size,
    });
    match sys.block_on(fut) {
        Ok(_) => (),
        Err(err) => {
            error!("Error creating camera group! {}", err);
        }
    }
    println!("Created camera group!");
    Ok(true)
}

fn main() {
    env_logger::init();

    dotenv().ok();
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");

    let mut sys = actix::System::new("Exopticon");

    // create db connection pool
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    let pool = r2d2::Pool::builder()
        .build(manager)
        .expect("Failed to create pool.");

    // Run migrations
    info!("Running migrations...");
    embedded_migrations::run_with_output(
        &pool.get().expect("migration connection failed"),
        &mut std::io::stdout(),
    )
    .expect("migrations failed!");

    let address: Addr<DbExecutor> = SyncArbiter::start(4, move || DbExecutor(pool.clone()));

    db_registry::set_db(address.clone());

    let db_address = address.clone();
    let route_db_address = address.clone();
    let setup_address = address;
    // secret is a random 32 character long base 64 string
    let secret_string: String =
        env::var("SECRET_KEY").unwrap_or_else(|_| encode(&rand::thread_rng().gen::<[u8; 32]>()));
    let secret = decode(&secret_string)
        .expect("Invalid SECRET_KEY env var provided. Must be 32bytes encoded as base64");

    // Initialize prometheus metrics
    let prometheus = PrometheusMetrics::new("exopticon", Some("/metrics"), None);
    prom_registry::set_metrics(prometheus.clone());

    thread::spawn(move || {
        let mut sys = System::new("metrics");
        let srv = HttpServer::new(move || App::new().wrap(prometheus.clone()))
            .bind("0.0.0.0:3001")
            .expect("Could not bind to 0.0.0.0:3000")
            .run();
        sys.block_on(srv)
            .expect("Failed to block on metrics server");
    });

    HttpServer::new(move || {
        App::new()
            .data(RouteState {
                db: route_db_address.clone(),
            })
            .wrap(IdentityService::new(
                CookieIdentityPolicy::new(&secret)
                    .name("id")
                    .path("/")
                    .max_age_time(Duration::days(7)) // just for testing
                    .secure(true)
                    .same_site(SameSite::Strict),
            ))
            // setup builtin logger to get nice logging for each request
            .wrap(Logger::default())
            .configure(app::generate_config)
    })
    .bind("0.0.0.0:3000")
    .expect("Can not bind to '0.0.0.0:3000'")
    .run();

    let mut mode = ExopticonMode::Run;
    let mut add_user_flag = false;
    let mut add_camera_group_flag = false;
    // Prints each argument on a separate line
    for argument in env::args() {
        match argument.as_ref() {
            "--standby" => {
                info!("Runtime mode is standby...");
                mode = ExopticonMode::Standby;
            }
            "--add-user" => {
                add_user_flag = true;
            }
            "--add-camera-group" => {
                add_camera_group_flag = true;
            }
            _ => (),
        }
    }

    if add_user_flag || add_camera_group_flag {
        mode = ExopticonMode::Standby;
    }

    let root_supervisor = RootSupervisor::new(mode, db_address);

    RootSupervisor::start_in_arbiter(
        actix::System::current().arbiter(),
        move |_ctx: &mut Context<RootSupervisor>| root_supervisor,
    );

    if add_user_flag && add_user(&mut sys, &setup_address).is_err() {
        error!("Error creating user!");
        return;
    }

    if add_camera_group_flag && add_camera_group(&mut sys, &setup_address).is_err() {
        error!("Error creating camera group!");
        return;
    }

    if add_user_flag || add_camera_group_flag {
        return;
    }

    sys.run().expect("Unable to run actix system.");
}
